
fn = "c:/data/synth_rois_1/synth_1roi_0000.bin"
out_fn = "c:/data/synth_rois_1/synth_1roi.bin"

import numpy as np
import os
import cv2


'''
BHF: I didn't really intend this for general consumption.
Take an image file containing a single ROI with the first line of 
pixels containing metadata. That file format is the binary format expected from
the M20 scanhead.

This script takes one of those files and generates 6 files, in the format 
as if it were generated by the GPixel eval board.

This script assumes that the file is 640x480 uint_16's. 3 phases, 2 frequencies, 3 permutations.
'''
def read_img_w_metadata(filename) :
    if filename.endswith('.npz') :
        tmp = np.load(filename)
    else :
        tmp = np.fromfile(filename, dtype=np.uint16)
    
    if isinstance(tmp, dict):
        a = tmp['arr_0'] #     
    else :
        a = tmp.astype(np.uint16)
    print(f'image size {a.shape} with type {a.dtype} for file {filename} with range {tmp.min()}/{tmp.max()}.')
    return a
    pass

def write_img_w_metadata(a, out_fn) :
    a.tofile(out_fn)
    pass

# 640*480*2*6 = 5529600 shorts for the image portion of the file
#  = 11059200 bytes for the image portion of the file.
# The file has 5531520 total shorts, which is 1920 shorts different. You moron. Only one line 640*3
def write_imgs_wout_metadata(a_, out_fp) :
    a = a_[640*3:] # skip over header
    a = np.right_shift(a, 4)
    out_dir, out_fn = os.path.split(out_fp)
    out_froot, out_fext = os.path.splitext(out_fn)
    print(f'size a {a.shape} a_ {a_.shape} writing to {out_dir} as {out_froot}')

    # OK, not that I'm expecting anyone to be interested in this.
    # This generates 6 files to mirror the output generated by the GPixel eval kit.
    # Unfortunately, the gpixel kit outputs the data highest frequency first, but 
    # actually names the files with the modulation_idx rather than the actual frequency.
    imlen = 640*480*3
    a[0*imlen:1*imlen].tofile(os.path.join(out_dir, out_froot + '_3.raw'))
    a[1*imlen:2*imlen].tofile(os.path.join(out_dir, out_froot + '_0.raw')) # higher frequency first.
    a[2*imlen:3*imlen].tofile(os.path.join(out_dir, out_froot + '_4.raw'))
    a[3*imlen:4*imlen].tofile(os.path.join(out_dir, out_froot + '_1.raw'))
    a[4*imlen:5*imlen].tofile(os.path.join(out_dir, out_froot + '_5.raw'))
    a[5*imlen:6*imlen].tofile(os.path.join(out_dir, out_froot + '_2.raw'))

def write_rois_w_metadata(a, out_fp) :
    rows_per_roi = 480
    cols = 640
    out_dir, out_fn = os.path.split(out_fp)
    out_fileroot, out_fileext = os.path.splitext(out_fn)
    for roiIdx in range(a.shape[0]) :
        a[roiIdx].tofile(os.path.join(out_dir, out_fileroot + f'_roi_{roiIdx:04d}.bin'))

    pass

if __name__ == '__main__' : 
    a = read_img_w_metadata(fn)
    #write_rois_w_metadata(a, out_fn)
    #write_img_w_metadata(a, out_fn)
    write_imgs_wout_metadata(a, out_fn)