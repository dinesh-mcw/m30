"""
file: numerical_utilities.py

Copyright (C) 2023 Lumotive, Inc. All rights reserved.

This file defines classes and functions that create and translate
numerical values between different formats related to MIPI data
or writing registers in fixed point format.
"""
import random
from typing import Union, List

import numpy as np

from bitstring import BitArray


def ptob_raw12(pixels: List[int]):
    """Converts a list of 12-bit numbers to a list of 8-bit bytes per MIPI
    CSI-2 RAW12 formatting. N input elements create M = 3/2 * N output
    elements; the input list is padded with zeros such that M is an integer.
    """
    ret = []
    for i in range(0, len(pixels), 2):
        lo = pixels[i]
        hi = 0x000 if (i + 1 >= len(pixels)) else pixels[i + 1]
        x = lo >> 4
        y = hi >> 4
        z = (hi & 0xf) << 4 | (lo & 0xf)
        ret.extend((x, y, z))
    return ret


def btop_raw12(bytes_: List[int]):
    """Converts a list of 8-bit bytes to a list of 12-bit numbers per MIPI
    CSI-2 RAW12 formatting. M input elements create N = 2/3 * M output
    elements; the input list is padded with zeros such that N is an integer.
    """
    ret = []
    for i in range(0, len(bytes_), 3):
        lo = bytes_[i]
        mi = 0x00 if (i + 1 >= len(bytes_)) else bytes_[i + 1]
        hi = 0x00 if (i + 2 >= len(bytes_)) else bytes_[i + 2]
        x = lo << 4 | hi & 0xf
        y = mi << 4 | (hi >> 4) & 0xf
        ret.extend((x, y))
    return ret


def ptob_raw16(pixels: List[int], swap_bytes: bool = False):
    """Converts a list of 16-bit numbers to a list of 8-bit bytes per MIPI
    CSI-2 RAW16 formatting. N input elements create M = 2 * N output
    elements.

    If swap_bytes is True, then the bytes in each 16-bit input pixel are
    swapped such that the input is effectively encoded as RAW8 and the correct
    pixel values can be recovered from the returned result using MIPI RAW8
    decoding. (See the MIPI CSI-2 spec for the similarities between RAW8 and
    RAW16.)
    """
    ret = []
    if swap_bytes:
        pvec = [(p & 0xff) << 8 | (p >> 8) for p in pixels]
    else:
        pvec = pixels
    for p in pvec:
        lo = p >> 8
        hi = p & 0xff
        ret.extend((lo, hi))
    return ret


def btop_raw16(bytes_: List[int], swap_bytes: bool = False):
    """Converts a list of 8-bit bytes to a list of 16-bit numbers per MIPI
    CSI-2 RAW16 formatting. M input elements create N = M / 2 output
    elements; the input list is padded with zeros such that N is an integer.

    If swap_bytes is True, then the bytes in each 16-bit output pixel are
    swapped such that the input is effectively decoded as RAW8 and the correct
    pixel values are recovered from the input, insofaras the input was encoded
    using MIPI RAW8. (See the MIPI CSI-2 spec for the similarities between RAW8
    and RAW16.)
    """
    ret = []
    for i in range(0, len(bytes_), 2):
        lo = bytes_[i]
        hi = 0x00 if (i + 1 >= len(bytes_)) else bytes_[i + 1]
        ret.append(lo << 8 | hi)
    if swap_bytes:
        return [(p & 0xff) << 8 | (p >> 8) for p in ret]
    else:
        return ret


def ptob_raw8(pixels: List[int]):
    """Converts a list of 16-bit numbers to a list of 8-bit bytes per MIPI
    CSI-2 RAW8 formatting. N input elements create M = 2 * N output
    elements.
    """
    return ptob_raw16(pixels, swap_bytes=True)


def btop_raw8(bytes_: List[int]):
    """Converts a list of 8-bit bytes to a list of 16-bit numbers per MIPI
    CSI-2 RAW8 formatting. M input elements create N = M / 2 output
    elements; the input list is padded with zeros such that N is an integer.
    """
    return btop_raw16(bytes_, swap_bytes=True)


def get_rand_uints(n_ints, n_bits, rand_seed=None):
    """Get a specified number of ints of the specified
    bitlength for the given random seed

    if seed is not passed the seed is generated by system time
    or available OS level randomness sources
    """
    random.seed(rand_seed)
    return [random.randint(0, 2 ** n_bits - 1) for i in range(n_ints)]


class FxpFormat:
    def __init__(self, signed, n_bits, n_frac):

        self.signed = signed
        if n_bits < 1:
            raise ValueError
        self.n_bits = n_bits
        self.n_frac = n_frac

    def __eq__(self, other):
        if not isinstance(other, FxpFormat):
            raise NotImplementedError
        return (
            self.signed == other.signed
            and self.n_bits == other.n_bits
            and self.n_frac == other.n_frac
        )

    @property
    def n_int(self):
        if self.signed:
            return self.n_bits - self.n_frac - 1
        else:
            return self.n_bits - self.n_frac

    @property
    def format(self):
        return (self.signed, self.n_bits, self.n_frac)

    @property
    def fxp_limits(self):
        return (self.fxp_min, self.fxp_max)

    @property
    def dig_limits(self):
        return (self.dig_min, self.dig_max)

    @property
    def fxp_max(self):
        if self.signed:
            return (2 ** (self.n_bits - 1) - 1) * 2 ** (-self.n_frac)
        else:
            return (2 ** (self.n_bits) - 1) * 2 ** (-self.n_frac)

    @property
    def fxp_min(self):
        if self.signed:
            return (-(2 ** (self.n_bits - 1))) * 2 ** (-self.n_frac)
        else:
            return 0.0

    @property
    def dig_max(self):
        return 2 ** (self.n_bits)

    @property
    def dig_min(self):
        return 0


class SignalVec:
    """A conversion class for various number formats

    currently supports:
    float
    fixed point (fxp)
    digital (hex/integers)
    binary (binary as string)

    >>> sv = SignalVec(True, 0,0)

    """
    def __init__(self, signed: bool, n_bits: int, n_frac: int, quant_func=np.round):
        self.fxpformat = FxpFormat(signed=signed, n_bits=n_bits, n_frac=n_frac)
        self._abs_data = None
        self.quant_func = quant_func

    def quantize(self):
        """Quantizes each floating point input value to its fixed-point value with
        the specified number of total bits (n_bits) and fractional bits (n_frac).
        For example, vals = -1.749 with n_bits = 4 and n_frac = 2 (i.e. the format
        is s1.2) is quantized to -1.75. By default, this function quantizes using
        convergent rounding to even (aka banker's rounding or numpy rounding) and
        protects from rounding overflow by clipping to the fixed-point value's
        limits. For example, 1.9999 with the same format (s1.2) is quantized to
        1.75 because 2 is not allowed. Alternatively, the Boolean use_floor can be
        used to quantize via the floor function, which is biased towards negative
        infinity. The input can be a single number or a numpy array.
        """
        quant = self.quant_func(self._abs_data * 2 ** self.fxpformat.n_frac)
        if self.fxpformat.signed:
            clip = np.clip(quant, -2 ** (self.fxpformat.n_bits - 1), 2 ** (self.fxpformat.n_bits - 1) - 1)
        else:
            clip = np.clip(quant, 0, 2 ** self.fxpformat.n_bits - 1)
        return clip / 2 ** self.fxpformat.n_frac

    def _clamp(self, val, mini, maxi):
        """Clamps val to either min, or max if exceeding those bounds other wise returns val"""
        if isinstance(val, np.ndarray):
            val = np.clip(val, self.fxpformat.fxp_min, self.fxpformat.fxp_max)
        elif isinstance(val, list):
            val = [self._clamp(x, self.fxpformat.fxp_min, self.fxpformat.fxp_max) for x in val]
        else:
            if mini > maxi:
                raise ValueError
            if val < mini:
                print(f'clamping {val} to minimum ({mini}) as it was out of range')
                val = mini
            elif val > maxi:
                print(f'clamping {val} to maximum ({maxi}) as it was out of range')
                val = maxi
        return val

    def set_float_vec(self, val: Union[float, int, list, np.ndarray]):
        if isinstance(val, (float, int)):
            val = np.array([float(val)])
        elif isinstance(val, list):
            val = np.array(val)
        for i, x in enumerate(val):
            val[i] = self._clamp(x, self.fxpformat.fxp_min, self.fxpformat.fxp_max)
        self._abs_data = val

    def get_float_vec(self):
        return self._abs_data

    def set_dig_vec(self, val: Union[int, list, np.ndarray]):
        """Set values using digital/integer representation"""
        if isinstance(val, int):
            val = np.array([val])
        elif isinstance(val, list):
            val = np.array(val)

        for i, x in enumerate(val):
            val[i] = self._clamp(x, self.fxpformat.dig_min, self.fxpformat.dig_max)
        # convert to floats
        conv = self.dig_to_fixed(val)
        # set to _data attr
        self._abs_data = conv

    def get_dig_vec(self):
        """Returns an integer whose bin() output is the signed two's-complement bit
        string of the input value. For example, vals = -1.75 with n_bits = 4 and
        n_frac = 2 (i.e. the format is s1.2) is converted to 9 because the bit
        string of 9 is '1001' and -1.75 is 10.01 in fixed-point. The input can
        be a single number or a numpy array.
        """
        return self.fixed_to_dig()

    def set_fxp_vec(self, val: Union[float, list, int, np.ndarray]):
        if isinstance(val, (float, int)):
            val = np.array([val])
        if isinstance(val, list):
            val = np.array(val)
        for i, x in enumerate(val):
            val[i] = self._clamp(x, self.fxpformat.fxp_min, self.fxpformat.fxp_max)
        self._abs_data = val

    def get_fxp_vec(self):
        """Returns the fixed-point value (as a float) for each input value using
        the specified number of total bits (n_bits) and fractional bits (n_frac).
        For example, with n_bits = 4 and n_frac = 2 (i.e. the format is s1.2), the
        value 9 is converted to -1.75 because the bitstring of 9 is '1001' and
        10.01 is -1.75 in fixed-point. The input can be a single number or a numpy
        array.
        """
        return self.quantize()

    def set_twoscomp_vec(self, val: Union[str, list, np.ndarray]):
        """takes binary strings and sets the values for the abstract value"""
        if isinstance(val, int):
            val = np.array([val])
        elif isinstance(val, list):
            val = np.array(val)
        abs_data = self.bin2float(val)
        self._abs_data = abs_data

    def get_twoscomp_vec(self):
        val = [self.to_binary(x) for x in self._abs_data]
        return val

    def bin2float(self, bin_array):
        """
        Convert twos-complement fractional binary array to float.
        Args:
            bin_array: a number array of str bin strings
            fxp_fmt (tuple): (signed (bool), n_bits (int), n_frac (int))

        Returns:
            float_array: a number array of dtype float
        """

        float_array = np.empty(bin_array.shape, dtype=float)

        it = np.nditer(bin_array, flags=['multi_index'])

        while not it.finished:
            if type(it[0]) is np.ndarray:
                bin_str = it[0].item()
            else:
                bin_str = it[0]

            float_array[it.multi_index] = self.binary_str_to_decimal(bin_str)
            it.iternext()

        return float_array

    def float2bin(self, float_array):
        """
        Convert every value of array from float (decimal) to binary representation
        Args:
            float_array: a number array of dtype float
            fxp_fmt (tuple): (signed (bool), n_bits (int), n_frac (int))

        Returns:
            bin_array: the same array as float_array but using binary representation
        """
        if not isinstance(float_array, np.ndarray):
            raise ValueError("To convert a single value use to_binary")
        bin_array = np.empty(float_array.shape, dtype=object)

        it = np.nditer(float_array, flags=['multi_index'])

        while not it.finished:
            if type(it[0]) is np.ndarray:
                float_value = it[0].item()
            else:
                float_value = it[0]

            bin_array[it.multi_index] = self.to_binary(float_value)
            it.iternext()

        return bin_array

    def binary_str_to_decimal(self, s):
        """
        Convert twos-complement fractional binary to float.
        Args:
            s: binary string
        Returns:
            float number
        """
        ba = BitArray(bin=s)
        if self.fxpformat.signed:
            value = ba.int
        else:
            value = ba.uint
        value_scaled = float(value) * 2.0 ** (-self.fxpformat.n_frac)
        return value_scaled

    def to_binary(self, x):
        """
        Convert value to twos-complement binary.
        Args:
            x: Value
            fxp_fmt (tuple): (signed (bool), n_bits (int), n_frac (int))
        Returns:
            Twos-complement representation of x in binary format.
        """
        if self.fxpformat.signed:
            max_fxp = ((2 ** (self.fxpformat.n_bits - 1) - 1)
                       * 2 ** (-self.fxpformat.n_frac))
            min_fxp = ((-(2 ** (self.fxpformat.n_bits - 1)))
                       * 2 ** (-self.fxpformat.n_frac))
        else:
            max_fxp = ((2 ** self.fxpformat.n_bits - 1)
                       * 2 ** (-self.fxpformat.n_frac))
            min_fxp = 0
        if x > max_fxp:
            x = max_fxp
        elif x < min_fxp:
            x = min_fxp
        x_scale = x * 2 ** self.fxpformat.n_frac
        if self.fxpformat.signed:
            bin_val = BitArray(int=int(x_scale), length=self.fxpformat.n_bits)
        else:
            bin_val = BitArray(uint=int(x_scale), length=self.fxpformat.n_bits)
        s = bin_val.bin
        if self.fxpformat.n_frac > 0:
            xf_fract = s[-self.fxpformat.n_frac:]
        else:
            xf_fract = ""
        xf_pos = s[0:self.fxpformat.n_bits - self.fxpformat.n_frac]

        return xf_pos + '.' + xf_fract

    def fixed_to_dig(self):
        """Returns an integer whose bin() output is the signed two's-complement bit
        string of the input value. For example, vals = -1.75 with n_bits = 4 and
        n_frac = 2 (i.e. the format is s1.2) is converted to 9 because the bit
        string of 9 is '1001' and -1.75 is 10.01 in fixed-point. The input can
        be a single number or a numpy array.
        """
        qval = self.quantize()
        return np.array(qval
                        * 2 ** self.fxpformat.n_frac
                        % 2 ** self.fxpformat.n_bits).astype(np.int64)

    def dig_to_fixed(self, vals):
        """Converts digital integer values to fixed point value
        based on the numerical format
        """
        if not isinstance(vals, np.ndarray):
            vals = np.array(vals)

        if self.fxpformat.signed:
            vals = np.where(vals < 2 ** (self.fxpformat.n_bits - 1),
                            vals,
                            vals - 2 ** self.fxpformat.n_bits)
            return vals * 2 ** (-self.fxpformat.n_frac)
        else:
            return vals * 2 ** (-self.fxpformat.n_frac)
